# Hypothesis tests {#hypothesis-tests}

```{r setup-hypothesis-tests, include=FALSE, purl=FALSE}
chap <- 12
lc <- 0
rq <- 0
# **`r paste0("(LC", chap, ".", (lc <- lc + 1), ")")`**
# **`r paste0("(RQ", chap, ".", (rq <- rq + 1), ")")`**
knitr::opts_chunk$set(
  tidy = FALSE,
  out.width = '\\textwidth',
  fig.height = 4,
  fig.align='center',
  warning = FALSE
  )
options(scipen = 99, digits = 3)
# Set random number generator see value for replicable pseudorandomness.
set.seed(2018)
```

In Chapter \@ref(pvalues), we introduced the p-value, which provides analysts with a probability (between 0 and 1) that the observed data would be found if the null hypothesis were true. Readers familiar with the use of statistics may have noticed, however, that Chapter \@ref(pvalues) did not refer to any criteria (e.g., p < .05) or use the phrase “statistically significant”. This is because the concept of a p-value is distinct from the use of a p-value to make a decision. In this chapter, we introduce hypothesis testing, which can be used for just this purpose.

### Needed Packages {-}

Let’s load all the packages needed for this chapter (this assumes you’ve already installed them). If needed, read Section \@ref(packages) for information on how to install and load R packages.

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
library(moderndive)
library(infer)
library(ggplot2movies)
```

```{r message=FALSE, warning=FALSE, echo=FALSE}
# Packages needed internally, but not in text.
library(readr)
library(knitr)
library(kableExtra)
library(patchwork)
library(scales)
```

## Decision making {#decision-making}

Remember that a p-value is a probabilistic proof by contradiction. It might show that the chance that the observed data would occur under the null hypothesis is 2%, 20%, or 50%. But at what level is the evidence enough that we would decide that the null hypothesis must not be true?

Conventional wisdom is to use $p < 0.05$ as this threshold, where $p$ denotes the p-value. But as many have pointed out – particularly in the current ‘replication crisis’ era – this threshold is arbitrary. Why is 5% considered small enough? Why not 0.5%? Why not 0.05%? Decisions regarding these thresholds require substantive knowledge of a field, the role of statistics in science, and some important trade-offs, which we will introduce next.

<!-- link to a replication crisis article? -->

## Decision making trade-offs {#trade-offs}

Imagine that you’ve been invited to a party, and you are trying to decide if you should go. On the one hand, the party might be a good time, and you’d be happy that you went. On the other hand, it might not be that much fun and you’d be unhappy that you went. In advance, you don’t know which kind of party it will be. How do you decide?
We can formalize this decision making in terms of a 2x2 table crossing your decision (left) with information about the party (top):

```{r party-table, echo=FALSE, message=FALSE}
if(!file.exists("rds/party_table.rds")){
  party_table <- "https://docs.google.com/spreadsheets/d/e/2PACX-1vTFrvHwKsz8Jp2z3W48yxYO3PnbUUCy8CwBzn9WjiFhrB0OQQaLx8gte64gz0L1O2BlGq6hARAHb3NG/pub?output=csv" %>%
    read_csv(na = "")
    write_rds(party_table, "rds/party_table.rds")
} else {
  party_table <- read_rds("rds/party_table.rds")
}
party_table %>%
  kable(
    caption = "Party decision making",
    booktabs = TRUE,
    escape = FALSE
  ) %>%
  kable_styling(font_size = ifelse(knitr:::is_latex_output(), 10, 16),
                latex_options = c("HOLD_position"))
```

As you can see from this table, there are 4 possible combinations. If you decide to go to the party and it is in fact fun, you’re happy. If you decide to stay home and you hear from your friends that it was terrible, you’re happy. But in the other two cases you are *not happy*:

* Type I error: You decide to go to the party and the party is lame. You’ve now wasted your time and are unhappy.
* Type II error: You decide to forgo the party and stay home, but you later hear that the party was awesome. You’ve now missed out and are unhappy.

In life, we often have to make decisions like this. In making these decisions, there are trade-offs. Perhaps you are the type of person that has FOMO – in that case, you may really want to minimize your Type II error, but at the expense of attending some boring parties and wasting your time (a higher Type I error). Or perhaps you are risk averse and hate wasting time – in which case you want to minimize your Type I error, at the expense of missing out on some really great parties (a higher Type II error).

There are a few important points here:
* When making a decision, you cannot know in advance what the actual outcome will be.
* Sometimes your decision will be the right one. Ideally, you’d like this to be most of the time.
* But, sometimes your decision will be the wrong one. Importantly, you cannot minimize both Type I and II errors at the same time. One will be minimized at the expense of the other.
* Depending upon the context, you may decide that minimizing Type I or II errors is more important to you.

These features of decision-making play out again and again in life. In the next sections, we provide two common examples, one in medicine, the other in law.

### Medicine {#medicine}
Imagine that you might be pregnant and take a pregnancy test. This test is based upon levels of HcG in your urine, and when these levels are “high enough” (determined by the pregnancy test maker), the test will tell you that you are pregnant (+). If the levels are not “high enough”, the test will tell you that you are not pregnant (-). Depending upon how the test determines “high enough” levels of HcG, however, the test might be wrong. To see how, examine the following table.

```{r medicine-table, echo=FALSE, message=FALSE}
if(!file.exists("rds/medicine_table.rds")){
  medicine_table <- "https://docs.google.com/spreadsheets/d/e/2PACX-1vTmSF5bh4fg-QeydYItlgDUYUXCyM-axGzqMqRdwKfR7somtZ12L4kWgEXSbc5CEC4rS7aiffGb_N8D/pub?output=csv" %>%
    read_csv(na = "")
    write_rds(medicine_table, "rds/medicine_table.rds")
} else {
  medicine_table <- read_rds("rds/medicine_table.rds")
}
medicine_table %>%
  kable(
    caption = "Pregnancy test decision making",
    booktabs = TRUE,
    escape = FALSE
  ) %>%
  kable_styling(font_size = ifelse(knitr:::is_latex_output(), 10, 16),
                latex_options = c("HOLD_position"))
```

As the table notes, in two of the cases, the test correctly determines that you are either pregnant or not pregnant. But there are also two cases in which the test (a decision) is incorrect:

* Type I error: False Positive. In this case, the test tells you that you are pregnant when in fact you are not. This would occur if the level of HcG required to indicate positive was too low.
* Type II error: False Negative. In this case, the test tells you that you are not pregnant but you actually are. This would occur if the level of HcG required to indicate positive is too high.

When a pregnancy test manufacturer develops the test, they have to pay attention to these two possible error types and think through the trade-offs of each. For example, if they wanted to minimize the Type II error (False Negative), they could just create a test that always tells people they are pregnant (i.e., HcG >= 0). Conversely, if they wanted to minimize the Type I error (False Positive), they could set the HcG level to be very high, so that it only detects pregnancy for those that are 6 months pregnant. Of course, the trade-off here is that certainly many who took the test would actually be pregnant, and yet the test would tell them otherwise.

In developing these tests, which do you think test manufacturers focus on minimizing: Type I or II errors?

### Law {#law}
Imagine that you are on the jury of a criminal trial. You are presented with evidence that a crime has been committed and must make a decision regarding the guilt of the defendant. But you were not there when the crime was committed, so it is impossible to know with 100% accuracy that your decision is correct. Instead, you again encounter this 2x2 table:

```{r law-table, echo=FALSE, message=FALSE}
if(!file.exists("rds/law_table.rds")){
  law_table <- "https://docs.google.com/spreadsheets/d/e/2PACX-1vThQr10AKx5Asna-4yB-0kDKoQrycroVKL-Dvfm7F5HsLkTZyic_fDav18AUN4hnTIeEaZW1zXY0Amt/pub?output=csv" %>%
    read_csv(na = "")
    write_rds(law_table, "rds/law_table.rds")
} else {
  law_table <- read_rds("rds/law_table.rds")
}
law_table %>%
  kable(
    caption = "Criminal trial decision making",
    booktabs = TRUE,
    escape = FALSE
  ) %>%
  kable_styling(font_size = ifelse(knitr:::is_latex_output(), 10, 16),
                latex_options = c("HOLD_position"))
```

As the table notes, in two of the cases, the jury correctly determines that the defendant is either guilty or not. But there are also two cases in which the jury’s decision is incorrect:
* Type I error: Wrongly Convicted. In this case, the jury decides that the defendant is guilty when in fact they are not. This might be because evidence that was presented was falsified or because prejudices and discrimination affect how the jury perceives the defendant.
* Type II error: Insufficient Evidence. In this case, the jury decides that the defendant is “not guilty” when in fact they are. This is typically because there is insufficient evidence.

In the US court system, the assumption is supposed to be that a defendant is innocent until proven guilty, meaning that a high burden of proof is required to find a defendant guilty. This means that the system is designed to have a low Type I error. The trade-off implicit in this is that the Type II error may be higher – that is, that because the burden of proof is high, some perpetrators will “get off”. (Note, of course, that we’re describing the ideal; as the [Innocence Project’s work](https://www.innocenceproject.org) shows, Type I errors are more common than we’d like, particularly among racial minorities).

### Commonalities
Before connecting these to statistical decision making, it’s interesting to note that in all three of the cases we’ve introduced here – party attendance, medicine, and law – the minimization of Type I error is often primary. That is, we’d prefer a decision rule that doesn’t send us to parties we don’t like, doesn’t tell us we are pregnant when we aren’t, and doesn’t wrongfully convict people of crimes. This is not to say Type II error doesn’t matter, but that it is often seen as secondary to Type I.

## Hypothesis test: Decision making in statistics {#ht}
The same sort of decision making problems face statistics as well: based on some p-value criterion, we could either reject the null hypothesis or not. And either the null hypothesis is true, or it is not – in which case some *alternative* hypothesis must be true.

This is the first time we have mentioned an **alternative hypothesis**. This hypothesis is what we are seeking evidence to prove when we are conducting what is called a **hypothesis test**:

```{r ht-table, echo=FALSE, message=FALSE}
if(!file.exists("rds/ht_table.rds")){
  ht_table <- "https://docs.google.com/spreadsheets/d/e/2PACX-1vSewsAMZzqDMnWezCZRUnXRBQuzTPdMDuO3q_z6vGipUz_XKtkziTsZaby30bAZVCgKmh_q8mnJgUGe/pub?gid=1481362109&single=true&output=csv" %>%
    read_csv(na = "")
    write_rds(ht_table, "rds/ht_table.rds")
} else {
  ht_table <- read_rds("rds/ht_table.rds")
}
ht_table %>%
  kable(
    caption = "Hypothesis test decision making",
    booktabs = TRUE,
    escape = FALSE
  ) %>%
  kable_styling(font_size = ifelse(knitr:::is_latex_output(), 10, 16),
                latex_options = c("HOLD_position"))
```
There is a lot of new information here to define:
* We **reject** the null hypothesis if the p-value is smaller than some threshold (i.e., p < threshold).
* We **do not reject** the null hypothesis if the p-value is larger than this threshold (i.e., p > threshold).
* The **null model** is as we’ve defined it in Chapter 11. In most cases it is that there is no effect, no difference, or no relationship. (Other null hypotheses are possible, these are just the most common.)
* The **alternative model** is a model we are seeking evidence to prove is correct. For example, the alternative model may be that there is an average non-zero difference between men and women’s SAT scores. Or that there is a correlation between income and education. Specifying an alternative can be tricky – usually this is based both on substantive knowledge and findings from prior studies.

Just as in the other decision-making context, there are two cases in which these decisions are correct, and two cases in which they are not:

* $\boldsymbol{\alpha} =$ **Type I error:** The test rejects the null hypothesis (because p < threshold), yet the null hypothesis is actually true. For example, the test indicates that there is a relationship between education and income when in fact there is not.
* $\boldsymbol{\beta =}$ **Type II error:** The test does not reject the null hypothesis (because p > threshold), but the alternative hypothesis is actually true. For example, the test indicates that there is not enough evidence to indicate a relationship between education and income, yet in fact there is a relationship.

Just as in your social life, medicine, and law, these two error types are in conflict with one another. A test that minimizes Type I error completely (by setting the threshold to 0) *never* rejects the null hypothesis, thus maximizing the Type II error. And vice versa, a test that minimizes Type II error completely (by setting the threshold to 1) *always* rejects the null hypothesis, thus maximizing the Type I error.

In science, these values have been somewhat arbitrarily set as:

* $\boldsymbol{\alpha} =$ **Type I error:** set the threshold to 0.05. Thus, finding that there is a 5% or smaller chance under the null hypothesis that a sample would produce a result this extreme is deemed sufficient evidence to decide the null hypothesis is not true.
* $\boldsymbol{\beta =}$ **Type II error:** 0.20. That is, we are willing to accept that there is a 20% chance that we do not reject the null hypothesis when in fact the alternative hypothesis is true.

This use of a threshold for rejecting a null hypothesis gives rise to some important language:

* When $p < 0.05$ (or whatever threshold is used), we say that we **reject the null hypothesis**. This is often referred to as a “statistically significant” effect.
* When $p > 0.05$ (or whatever threshold is used), we say that we **do not have enough evidence to reject the null hypothesis**. Note that it is not appropriate to say that we *accept* the null hypothesis.

Finally, there is one more piece of vocabulary that is important:

* **Power** = 1 – Type II error = $1-\beta$.

**Power** is the probability that we will reject the null hypothesis when in fact it is false. For example, if our Type II error is 0.20, then we can say our test has 80% power for rejecting the null hypothesis when the alternative hypothesis is true. Conversely, if a study has not been designed well, it may be **under-powered** to detect an effect that is substantively important. The power of a hypothesis test depends on:

* The magnitude of the effect (e.g. how big the true parameter value is in the population)
* Sample size (n)
* The type I error rate ($\alpha$)
* Sometimes other sample statistics

## Conducting Hypothesis Tests

In data analysis, hypothesis tests can be broken down into the following framework given by Allen Downey [here](http://allendowney.blogspot.com/2016/06/there-is-still-only-one-test.html):

```{r ht-framework, echo=FALSE, fig.cap="Hypothesis Testing Framework", purl=FALSE}
knitr::include_graphics("images/ht.png")
```

In practice, conducting a hypothesis test is straightforward:

* Determine the sampling distribution based upon the null model
* Find the test-statistic value observed in your data
* Calculate a p-value
* Reject the null hypothesis if the p-value is less than a pre-defined threshold.

This last point is significant – for the hypothesis test to be valid, **you must pre-specify your threshold, not after you have seen the p-value in your data.**

### Promotions Example {#ht-activity}

Let's consider a study that investigated gender discrimination in the workplace that was published in the "Journal of Applied Psychology" in 1974. This data is also used in the [OpenIntro](https://www.openintro.org/) series of statistics textbooks. Study participants included 48 male bank supervisors who attended a management institute at University of North Carolina in 1972. The supervisors were asked to assume the hypothetical role of a personnel director at the bank. Each supervisor was given a job candidate's personnel file and asked to decide whether or not the candidate should be promoted to a manager position at the bank.

Each of the personnel files given to the supervisors were identical except that half of them indicated that the candidate was female and half indicated the candidate was male. Personnel files were randomly distributed to the 48 supervisors. Because only the candidate's gender varied from file to file, and the files were randomly assigned to study participants, the researchers were able to isolate the effect of gender on promotion rates.  

The `moderndive` package contains the data on the 48 candidates in the `promotions` data frame. Let’s explore this data first:

```{r}
promotions
```

The variable `id` acts as an identification variable for all 48 rows, the `decision` variable indicates whether the candidate was selected for promotion or not, while the `gender` variable indicates the gender of the candidate indicated on the personnel file. Recall that this data does not pertain to 24 actual men and 24 actual women, but rather 48 identical personnel files of which 24 were indicated to be male candidates and 24 were indicated to be female candidates.

Let's perform an exploratory data analysis of the relationship between the two categorical variables `decision` and `gender`. Recall that we saw in Section \@ref(two-categ-barplot) that one way we can visualize such a relationship is using a stacked barplot.

```{r promotions-barplot, fig.cap="Barplot of relationship between gender and promotion decision."}
ggplot(promotions, aes(x = gender, fill = decision)) +
  geom_bar() +
  labs(x = "Gender on personnel file")
```

Observe in Figure \@ref(fig:promotions-barplot) that it appears that female personnel files were much less likely to be accepted for promotion.  Let's quantify these promotion rates by computing the proportion of personnel files accepted for promotion for each group using the `dplyr` package for data wrangling:

```{r}
promotions %>%
  group_by(gender, decision) %>%
  summarize(n = n())
```
```{r, echo=FALSE}
observed_point_estimate <- promotions %>%
  specify(decision ~ gender, success = "promoted") %>%
  calculate(stat = "diff in props", order = c("male", "female")) %>%
  pull(stat) %>%
  round(3)
```

So of the 24 male files, 21 were selected for promotion, for a proportion of 21/24 = 0.875 = 87.5%. On the other hand, of the 24 female files, 14 were selected for promotion, for a proportion of 14/24 = 0.583 = 58.3%. Comparing these two rates of promotion, it appears that males were selected for promotion at a rate 0.875 - 0.583 = `r observed_point_estimate` = `r observed_point_estimate*100` percentage points higher than females.

The question is however, does this provide *conclusive* evidence that there is gender discrimination in this context? Could a difference in promotion rates of `r observed_point_estimate*100`% still occur by chance, even in a hypothetical world where no gender-based discrimination existed? To answer this question, we can conduct the following hypothesis test:

$$H_0: \pi_m = \pi_f$$
$$H_1: \pi_m \neq \pi_f,$$
where $\pi_f$ is the proportion of female files selected for promotion and $\pi_m$ is the propotion of male files selected for promotion. Here the null hypothesis corresponds to the scenario in which there is *no gender discrimination*; that is, males and females are promoted at identical rates. We will specify this test ahead of time to have $\alpha = 0.05$. That is, we are comfortable with a 5% Type I error rate, and we will reject the null hypothesis if $p < 0.05$.

Note the null hypothesis can be rewritten as
$$H_0: \pi_m - \pi_f = 0$$ by subtracting $\pi_f$ from both sides. Therefore, the population parameter we are interested in estimating is $\pi_m - \pi_f$. Referring back to Table \@ref(tab:SE-table), we can see that the appropriate estimator is $\hat{\pi}_m - \hat{\pi}_f$. Under the null hypothesis, $\hat{\pi}_m - \hat{\pi}_f$ is normally distributed with mean $\pi_m - \pi_f$ and standard error $\sqrt{\frac{{\pi}_m(1-{\pi}_m)}{n_m} + \frac{{\pi}_f(1-{\pi}_f)}{n_f}}$.

Recall from Chapter \@ref(pvalues) that we calculate a test statistic using the following general formula:
$$test\_stat = \frac{Estimate - Null \ \ value}{SE(Estimate)}$$
In this example, we have $$test\_stat = \frac{(\hat{\pi}_m - \hat{\pi}_f) - 0}{\sqrt{\frac{\pi_m(1-\pi_m)}{n_m} + \frac{\pi_f(1-\pi_f)}{n_f}}}$$ Note that the null value here is $0$ because our null hypothesis states $\pi_m - \pi_f = 0$. We can use the promotions data to compute this observed test statistic. However, on the denominator we need separate values for $\pi_m$ and $\pi_f$, which aren't specified in our null hypothesis. When conducting a hypothesis test on the difference in proportions, we compute a *pooled* proportion to plug in for these unknown values. This pooled estimate, which we will denote $\pi_0$ can be calculated by $$\pi_{0} = \frac{\# \ of \ successes_1 + \# of successes_2}{n_1 + n_2}.$$ Therefore, the test statistic is computed by $$t\_stat = \frac{(\hat{\pi}_m - \hat{\pi}_f) - 0}{\sqrt{\frac{\pi_0(1-\pi_0)}{n_m} + \frac{\pi_0(1-\pi_0)}{n_f}}}$$

In the promotions example, $$\pi_0 = \frac{21 + 14}{24 + 24} = 0.729.$$ We can compute the test statistic with the following code.

```{r, promotions-t-stat}
results <- promotions %>%
  group_by(gender, decision) %>%
  summarize(n = n()) %>%
  mutate(prop = n / sum(n))
results

male_promotions <- as.numeric(results[2,3])
female_promotions <- as.numeric(results[4,3])

n_m <- 24
n_f <- 24

pi_0 <- (male_promotions + female_promotions) / (n_m + n_f)
pi_0
SE_pi_0 <- sqrt(pi_0 * (1 - pi_0) / n_m
           + pi_0 * (1 - pi_0) / n_f)
pi_hat_m <- as.numeric(results[2,4])
pi_hat_f <- as.numeric(results[4,4])
test_stat <- (pi_hat_m - pi_hat_f) / SE_pi_0
test_stat
```

Our test statistic is equal to `r round(test_stat,2)`, which we can now use to compute our p-value.

```{r}
p_value <- pnorm(test_stat, lower.tail = FALSE)*2
p_value
```

```{r, promotions-p-value, fig.cap = "P-value for Promotions Hypothesis Test", message = FALSE, echo = FALSE, warning = FALSE}
shade_curve <- function(MyDF, tstart, tend, fill = "red", alpha = .5){
  geom_area(data = subset(MyDF, x >= 0 + tstart
                          & x < 0 + tend),
            aes(y=y), fill = fill, color = NA, alpha = alpha)
}

data <- data.frame(x = seq(from = -5, to = 5, by = 0.01)) %>%
  mutate(y = dnorm(x))
ggplot(data.frame(x = c(-4, 4)), aes(x = x)) +
    stat_function(fun = dnorm,
                    aes(colour = "Z-distribution"), size = 1) +
  geom_vline(xintercept = test_stat, linetype = 2) +
  geom_vline(xintercept = -test_stat, linetype = 2) +
  shade_curve(data, tstart = -6, tend = -test_stat) +
  shade_curve(data, tstart = test_stat, tend = 6) +
  xlab("Z") +
  theme(legend.position = "none")

```
Note that we use the function `pnorm()` here because our test statistic follows the normal distribution. We set `lower.tail = FALSE` so that it gives us the probability in the left tail of the distribution, and we multiply by 2 because we are conducting a two-sided hypothesis test. The p-value = `r round(p_value, 2)` is represented by the shaded region in Figure \@ref(fig:promotions-p-value). Because our p-value is less than our pre-specified level of $\alpha = 0.05$, we **reject the null hypothesis** and conclude that there is sufficient evidence of gender discrimination in this context.

### Regression Example

We'll now demonstrate how to conduct a hypothesis test on regression coefficients by returning to our example from Chapter \@ref(regression) on teaching evaluations.

Recall using simple linear regression \index{regression!simple linear} we modeled the relationship between

1. A numerical outcome variable $y$, the instructor's teaching score and
1. A single numerical explanatory variable $x$, the instructor's "beauty" score.

We first created an `evals_ch6` data frame that selected a subset of variables from the `evals` data frame included in the `moderndive` package. This `evals_ch6` data frame contains only the variables of interest for our analysis, in particular the instructor's teaching `score` and the "beauty" rating `bty_avg`:

```{r}
evals_ch6 <- evals %>%
  select(ID, score, bty_avg, age)
glimpse(evals_ch6)
```
```{r, echo=FALSE}
cor_ch6 <- evals_ch6 %>%
  summarize(correlation = cor(score, bty_avg)) %>%
  pull(correlation) %>%
  round(3)
```

In Section \@ref(model1EDA), we performed an exploratory data analysis of the relationship between these two variables. We saw there that there was a weakly positive correlation of `r cor_ch6` between the two variables. This was evidenced in Figure \@ref(fig:regline) of the scatterplot along with the "best-fitting" regression line that summarizes the linear relationship between the two variables. Recall in Subsection \@ref(leastsquares) that we defined a "best-fitting" line as the line that minimizes the *sum of squared residuals*.

```{r regline, fig.cap="Relationship with regression line."}
ggplot(evals_ch6, aes(x = bty_avg, y = score)) +
  geom_point() +
  labs(x = "Beauty Score", y = "Teaching Score",
       title = "Relationship between teaching and beauty scores") +  
  geom_smooth(method = "lm", se = FALSE)
```

Looking at this plot again, you might be asking "Does that line really have all that positive of a slope?" It does increase from left to right as the `bty_avg` variable increases, but by how much? To get to this information, we can follow a two-step procedure:

1. We first "fit" the linear regression model using the `lm()` function with the formula `score ~ bty_avg`. We saved this model in `score_model`.
1. We get the regression results by applying the `summary()` function to `score_model` and accessing the `coefficients` object stored in the summary results.

```{r}
# Fit regression model:
score_model <- lm(score ~ bty_avg, data = evals_ch6)
# Get regression results:
summary(score_model)$coefficients
```
```{r regtable-12, echo=FALSE}
# Fit regression model:
score_model <- lm(score ~ bty_avg, data = evals_ch6)
#summary(score_model)$coefficients %>%
 # knitr::kable(
  #  digits = 5,
   # caption = "Linear regression table.",
  #  booktabs = TRUE
  #) %>%
  #kable_styling(font_size = ifelse(knitr:::is_latex_output(), 10, 16),
  #              latex_options = c("hold_position"))
# slope:
slope_row <- get_regression_table(score_model) %>%
  filter(term == "bty_avg")
beta_hat_1 <- slope_row %>% pull(estimate)
se1 <- slope_row %>% pull(std_error)
t1 <- slope_row %>% pull(statistic)
lower1 <- slope_row %>% pull(lower_ci)
upper1 <- slope_row %>% pull(upper_ci)
# intercept:
intercept_row <- get_regression_table(score_model) %>%
  filter(term == "intercept")
b0 <- intercept_row %>% pull(estimate)
se0 <- intercept_row %>% pull(std_error)
t0 <- intercept_row %>% pull(statistic)
lower0 <- intercept_row %>% pull(lower_ci)
upper0 <- intercept_row %>% pull(upper_ci)
```

Using the values in the `Estimate` column of the resulting regression table, we could then obtain the equation of the "best-fitting" regression line in Figure \@ref(fig:regline):

$$
\begin{aligned}
\widehat{y} &= \hat{\beta}_0 + \hat{\beta}_1 \cdot x\\
\widehat{\text{score}} &= \hat{\beta}_0 + b_{\text{bty}\_\text{avg}} \cdot\text{bty}\_\text{avg}\\
&= 3.880 + 0.067\cdot\text{bty}\_\text{avg}
\end{aligned}
$$

where $\hat{\beta}_0$ is the fitted intercept and $\hat{\beta}_1$ is the fitted slope for `bty_avg`. Recall the interpretation of the $\hat{\beta}_1$ = `r beta_hat_1` value of the fitted slope:

> For every increase of one unit in "beauty" rating, there is an associated increase, on average, of `r beta_hat_1` units of evaluation score.
Thus, the slope value quantifies the relationship between the y variable of `score` and the x variable `bty_avg`. We also discussed the intercept value of $\hat{\beta}_0$ = `r get_regression_table(score_model) %>% filter(term == "intercept") %>% pull(estimate)` and its lack of practical interpretation, since the range of possible "beauty" scores does not include 0.

We now want to formally test whether there is a relationship between teaching score and beauty score, beyond what we would expect simply due to chance. Recall the terminology and notation related to populations and samples that we studied in Chapter \@ref(populations). First, let's view the instructors for these `r nrow(evals_ch6)` courses as a *random sample* from a greater *population*. In our case, let's assume that the population is *all* instructors at UT Austin and that the sample of instructors who taught these 463 is a random sample. Unfortunately, we can only *assume* these two facts without more knowledge of the *sampling methodology*\index{sampling methodology} used by the researchers.

Since we are viewing these $n$ = 463 courses as a sample, we can view our fitted slope $\hat{\beta}_1$ = `r beta_hat_1` as a *point estimate* of the *population slope* $\beta_1$. In other words, $\beta_1$ quantifies the relationship between teaching `score` and "beauty" average `bty_avg` for *all* instructors at UT Austin. Similarly, we can view our fitted intercept $\hat{\beta}_0$ = `r b0` as a *point estimate* of the *population intercept* $\beta_0$ for *all* instructors at UT Austin.

Putting these two ideas together, we can view the equation of the fitted line $\widehat{y}$ = $\hat{\beta}_0 + \hat{\beta}_1 \cdot x$ = $3.880 + 0.067 \cdot \text{bty}\_\text{avg}$ as an estimate of some true and unknown *population line* $y = \beta_0 + \beta_1 \cdot x$.

In order to answer the question of whether there is a true relationship between teaching score and beauty score, we can test the following hypothesis:

$$H_0: \beta_1 = 0$$
$$H_1: \beta_1 \neq 0$$

Note that our null hypothesis corresponds to scenario where the slope is 0, which implies the regression line is simply equal to the horizontal line $y= \beta_0$. That is, there is no relationship between $x$ and $y$. Since we are now viewing our fitted slope $\hat{\beta}_1$ as a *point estimate* based on a *sample*, this estimate is subject to *sampling variability*, as we've seen numerous times throughout this book. In other words, if we collected new sample of data on a different set of $n$ = 463 courses and their instructors, the new fitted slope $\hat{\beta}_1$ will likely differ from `r beta_hat_1`. 

But by how much will it differ? In other words, by how much will this estimate *vary* across repeated samples? When taking sampling variation into account, do we still consider $\hat{\beta}_1$ to be different enough from 0 to reject the null hypothesis that $\beta_1 = 0$? The appropriate test statistic, which takes sampling variation into account via the standard error, will help us answer this question.

The test statistic for this hypothesis test is $$test\_stat = \frac{Estimate - Null \ \ value}{SE(Estimate)} = \frac{\hat{\beta}_1 - 0}{SE(\hat{\beta}_1)}$$

The standard error of $\hat{\beta}_1$ can be extracted from the regression summary output. We can store the model summary results in a new object called `model_results`. We can then access the coefficients and their standard errors by calling `model_results$coefficients`.

```{r}
model_results <- summary(score_model)
model_results$coefficients
```
Note that  $\hat{\beta}_1$ and its standard error are located in the second row and first and second columns of this matrix respectively. We can use these numbers to calculate our test statistic.

```{r}
beta_hat_1 <- model_results$coefficients[2,1]
SE_beta_hat_1 <- model_results$coefficients[2,2]
test_stat <- beta_hat_1 / SE_beta_hat_1
test_stat
```

Similar to what we saw in Chapter \@ref(pvalues), this test statistic follows a t-distribution with a specified degrees of freedom. Table \@ref(tab:reg-df) gives the appropriate degrees of freedom for tests of regression coefficients. 

```{r reg-df, echo=FALSE, message=FALSE}
if(!file.exists("rds/reg_df.rds")){
  reg_df <- "https://docs.google.com/spreadsheets/d/e/2PACX-1vTr6fghH9Et5CucPBRa87hagMV-UQjVpbH2Mxq18bT_S_XGVZtE9jy-mhYvWmUBTP3trPb2fSmhdsEy/pub?gid=0&single=true&output=csv" %>%
    read_csv(na = "")
    write_rds(reg_df, "rds/reg_df.rds")
} else {
  reg_df <- read_rds("rds/reg_df.rds")
}
reg_df %>%
  kable(
    caption = "t-test for regression coefficients",
    booktabs = TRUE,
    escape = FALSE
  ) %>%
  kable_styling(font_size = ifelse(knitr:::is_latex_output(), 10, 16),
                latex_options = c("HOLD_position"))
```

Note the $p$ refers to the number of explanatory variables in the regression model. In this example, we only have one explanatory variable $x$, the beauty score, so $p = 1$, and the degrees of freedom are $df = n - p - 1 = n - 2$. We can now use this information to calculate our p-value. 

```{r}
n <- dim(evals_ch6)[1]
p_value <- pt(test_stat, n-2, lower.tail = FALSE)*2
p_value
```
Note that our calculated `test_stat = ` `r test_stat` is the same value reported in the `t value` column of the regression output, and our calculated p-value is the same as the value reported in the `Pr(>|t|)` column of the regression output. 

```{r eval = FALSE, echo = FALSE}
#manual calculation of SE(beta_hat_1)
sx2 <- var(evals_ch6$bty_avg)
sy2 <- var(evals_ch6$score)
n <- dim(evals_ch6)[1]

Syy <- (n-1)*sy2
Sxy <- (n-1)*cov(evals_ch6$bty_avg, evals_ch6$score)
Sxx <- (n-1)*sx2
SSE <- Syy - Sxy^2/Sxx
MSE <- SSE / (n-2)
SE_beta_hat_1 <- sqrt(MSE)/sqrt(Sxx)
```

Because our $p-value < 0.05$, we can reject the null hypothesis and conclude there is a true relationship between beauty score and teaching score, beyond what would be expected by chance. 

## More advanced points to consider
As this is an introductory book, we have introduced some concepts but not developed them in full detail. This does not mean that there are not things to say about these – more that there is simply too much to say at this time. These topics include:

* **Planning studies:** If you are planning a study, you need to determine the sample size $n$ that is sufficient for minimizing Type II error (i.e, maximizing power). To do so, you will need to know the sampling distribution of the estimator not just under the null hypothesis, but also under the alternative hypothesis. You will need to specify the size of the outcome, difference, or relationship you are seeking to understand. From this, for a given Type II error level, you can determine the minimum sample size you will need.
* **Multiple testing:** We introduced the use of hypothesis testing here with a single test. When you are analyzing data, however, you often conduct multiple hypothesis tests on the same data. By conducting multiple hypothesis tests, in combination Type I error (what is called “familywise error rate”) is typically higher, and sometimes much higher, than the Type I error of each test in isolation. There are procedures you can use to adjust for this.
* **P-hacking:** Again, we have focused on hypothesis testing as if there is a single test and a single null model. But in practice, analysts might try many different specifications or models, with the goal of finding a test that rejects a null hypothesis (p < .05). Why might an analyst do this? Because the system of rewards in science often tips towards rewarding those that find effects (p < .05), not those that do not.
